package config

import (
	"fmt"
	"strings"
	"syscall"

	"github.com/ipfs/go-log"
	"github.com/keep-network/keep-common/pkg/chain/ethereum"
	ethereumCommon "github.com/keep-network/keep-common/pkg/chain/ethereum"
	"github.com/keep-network/keep-core/pkg/beacon/registry"
	ethereumChain "github.com/keep-network/keep-core/pkg/chain/ethereum"
	ethereumBeaconGen "github.com/keep-network/keep-core/pkg/chain/ethereum/beacon/gen"
	"github.com/keep-network/keep-core/pkg/net/libp2p"
	"github.com/mitchellh/mapstructure"
	"github.com/spf13/viper"
	"golang.org/x/crypto/ssh/terminal"
)

var logger = log.Logger("keep-config")

// Environment variables names for properties configuration. For simplification we
// bind the names that are different from the auto-generated by viper with the
// `viper.AutomaticEnv()` function. For example instead of expecting
// `KEEP_ETHEREUM_ACCOUNT_KEYFILEPASSWORD` we expect `KEEP_ETHEREUM_PASSWORD`.
const (
	// #nosec G101 (look for hardcoded credentials)
	// This line doesn't contain any credentials.
	// It's just the name of the environment variable.
	ethereumPasswordEnvVariable         = "KEEP_ETHEREUM_PASSWORD"
	ethereumKeyFileEnvVariable          = "KEEP_ETHEREUM_KEYFILE"
	libp2pPeersEnvVariable              = "KEEP_PEERS"
	libp2pPortEnvVariable               = "KEEP_PORT"
	libp2pAnnouncedAddressesEnvVariable = "KEEP_ANNOUNCED_ADDRESSES"
	storageDataDirEnvVariable           = "KEEP_STORAGE_DIR"
)

// Config is the top level config structure.
type Config struct {
	Ethereum    ethereumCommon.Config
	LibP2P      libp2p.Config
	Storage     Storage
	Metrics     Metrics
	Diagnostics Diagnostics
}

// Storage stores meta-info about keeping data on disk
type Storage struct {
	DataDir string
}

// Metrics stores meta-info about metrics.
type Metrics struct {
	Port                int
	NetworkMetricsTick  int
	EthereumMetricsTick int
}

// Diagnostics stores diagnostics-related configuration.
type Diagnostics struct {
	Port int
}

var (
	// KeepOpts contains global application settings
	KeepOpts Config
)

// ReadConfig reads in the configuration file at `filePath` and returns the
// valid config stored there, or an error if something fails while reading the
// file or the config is invalid in a known way.
func ReadConfig(filePath string) (*Config, error) {
	config := &Config{}
	if err := loadConfig(filePath, config); err != nil {
		return nil, fmt.Errorf("unable to load config (file: [%s]): [%w]", filePath, err)
	}

	if config.Ethereum.Account.KeyFile == "" {
		return nil, fmt.Errorf("missing value for ethereum key file")
	}

	if config.LibP2P.Port == 0 {
		return nil, fmt.Errorf("missing value for port; see node section in config file or use --port flag")
	}

	if config.Storage.DataDir == "" {
		return nil, fmt.Errorf("missing value for storage directory data")
	}

	if strings.TrimSpace(config.Ethereum.Account.KeyFilePassword) == "" {
		var (
			password string
			err      error
		)
		fmt.Printf(
			"Ethereum Account Password has to be set for the configured Ethereum Key File.\n"+
				"Please set %s environment variable, or set it in the config file, or provide it in the prompt below.\n",
			ethereumPasswordEnvVariable,
		)

		for strings.TrimSpace(password) == "" {
			if password, err = readPassword("Enter Ethereum Account Password: "); err != nil {
				return nil, err
			}
		}

		config.Ethereum.Account.KeyFilePassword = password
	}

	return config, nil
}

// ReadEthereumConfig reads in the configuration file at `filePath` and returns
// its contained Ethereum config, or an error if something fails while reading
// the file.
//
// This is the same as invoking ReadConfig and reading the Ethereum property
// from the returned config, but is available for external functions that expect
// to interact solely with Ethereum and are therefore independent of the rest of
// the config structure.
func ReadEthereumConfig(filePath string) (ethereum.Config, error) {
	config, err := ReadConfig(filePath)
	if err != nil {
		return ethereum.Config{}, err
	}

	return config.Ethereum, nil
}

// loadConfig uses viper to load configuration from a TOML config file or environment
// variables. If the config file is not found it fallbacks to the environment variables.
// The environment variables are preferred over the values set in the config file.
func loadConfig(configFilePath string, config *Config) error {
	v := viper.New()

	// Read configuration from a TOML file, located in `configFilePath`.
	v.SetConfigFile(configFilePath)

	// Environment variables are expected to be prefixed with `KEEP_` and use `_`
	// as levels delimiter (but they are accessible in viper with `.`). For example,
	// environment variable `KEEP_ETHEREUM_URL` is resolved to the `Ethereum.URL`
	// config property.
	v.AutomaticEnv()
	v.SetEnvPrefix("KEEP")
	v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

	// Configure Ethereum.
	if err := v.BindEnv("Ethereum.URL"); err != nil {
		return err
	}
	if err := v.BindEnv("Ethereum.URLRPC"); err != nil {
		return err
	}
	if err := v.BindEnv("Ethereum.Account.KeyFilePassword", ethereumPasswordEnvVariable); err != nil {
		return err
	}
	if err := v.BindEnv("Ethereum.Account.KeyFile", ethereumKeyFileEnvVariable); err != nil {
		return err
	}

	// Configure default contract addresses.
	bindEnvContractAddress := func(contractName string, defaultAddress string) (err error) {
		configProperty := fmt.Sprintf("Ethereum.ContractAddresses.%s", contractName)
		err = v.BindEnv(
			configProperty,
			strings.ToUpper(
				fmt.Sprintf("KEEP_ETHEREUM_CONTRACTS_%s", contractName),
			),
		)
		v.SetDefault(configProperty, defaultAddress)

		return
	}

	if err := bindEnvContractAddress(
		ethereumChain.RandomBeaconContractName,
		ethereumBeaconGen.RandomBeaconAddress,
	); err != nil {
		return err
	}

	// Configure LibP2P.
	if err := v.BindEnv("LibP2P.Peers", libp2pPeersEnvVariable); err != nil {
		return err
	}

	if err := v.BindEnv("LibP2P.Port", libp2pPortEnvVariable); err != nil {
		return err
	}
	v.SetDefault("LibP2P.Port", libp2p.DefaultPort)

	if err := v.BindEnv("LibP2P.AnnouncedAddresses", libp2pAnnouncedAddressesEnvVariable); err != nil {
		return err
	}

	// Configure Storage.
	if err := v.BindEnv("Storage.DataDir", storageDataDirEnvVariable); err != nil {
		return err
	}
	v.SetDefault("Storage.DataDir", registry.DefaultStoragePath)

	// TODO: Add support for command line flags.

	// Read configuration.
	if err := v.ReadInConfig(); err != nil {
		if _, ok := err.(viper.ConfigFileNotFoundError); ok {
			logger.Warningf("config file not found: %s", configFilePath)
		} else {
			return fmt.Errorf("failed to read configuration: %w", err)
		}
	}

	if err := v.Unmarshal(
		&config,
		viper.DecodeHook(
			mapstructure.ComposeDecodeHookFunc(
				mapstructure.StringToTimeDurationHookFunc(),
				mapstructure.StringToSliceHookFunc(","),
				mapstructure.TextUnmarshallerHookFunc(),
			),
		),
	); err != nil {
		return fmt.Errorf("failed to unmarshal configuration: %w", err)
	}

	return nil
}

// ReadPassword prompts a user to enter a password.   The read password uses
// the system password reading call that helps to prevent key loggers from
// capturing the password.
func readPassword(prompt string) (string, error) {
	fmt.Print(prompt)
	bytePassword, err := terminal.ReadPassword(int(syscall.Stdin))
	fmt.Print("\n")
	if err != nil {
		return "", fmt.Errorf("unable to read password, error [%s]", err)
	}

	return strings.TrimSpace(string(bytePassword)), nil
}
